initSidebarItems({"struct":[["Chunk","An iterator for the elements in a single chunk.Iterator element type is `I::Item`."],["Chunks","An iterator that yields the Chunk iterators.Iterator element type is `Chunk`.See `.chunks_lazy()` for more information."],["ChunksLazy","`ChunkLazy` is the storage for a lazy chunking operation.`ChunksLazy` behaves just like `GroupByLazy`: it is iterable, and it only buffers if several chunk iterators are alive at the same time.This type implements `IntoIterator` (it is **not** an iterator itself), because the chunk iterators need to borrow from this value. It should be stored in a local variable or temporary and iterated.Iterator element type is `Chunk`, each chunk's iterator.See `.chunks_lazy()` for more information."],["Group","An iterator for the elements in a single group.Iterator element type is `I::Item`."],["GroupByLazy","`GroupByLazy` is the storage for the lazy grouping operation.If the groups are consumed in their original order, or if each group is dropped without keeping it around, then `GroupByLazy` uses no allocations. It needs allocations only if several group iterators are alive at the same time.This type implements `IntoIterator` (it is **not** an iterator itself), because the group iterators need to borrow from this value. It should be stored in a local variable or temporary and iterated.See `.group_by_lazy()` for more information."],["Groups","An iterator that yields the Group iterators.Iterator element type is `(K, Group)`: the group's key `K` and the group's iterator.See `.group_by_lazy()` for more information."]]});